# 边缘检测微分算子介绍

## 1.一阶导数的边缘算子

Roberts算子、Sobel算子、Prewitt算子

### 1.1 Robert算子

又称为交叉微分算法，它是基于交叉差分的梯度算法，通过局部差分计算检测边缘线条。常用来处理具有陡峭的低噪声图像，当图像边缘接近于正45度或负45度时，该算法处理效果更理想。其缺点是对边缘的定位不太准确，提取的边缘线条较粗。

Roberts算子的**模板**分为水平方向和垂直方向，如下式所示，从其模板可以看出，Roberts算子能较好的增强正负45度的图像边缘。

$$d_x=\begin{bmatrix} -1 & 0\\ 0 & 1\end{bmatrix},d_y=\begin{bmatrix}0 & -1\\  1 & 0 \end{bmatrix}$$

![](https://img-blog.csdnimg.cn/20190505104614320.png)

如图，P5在$x$方向和$y$方向的梯度分别为

$$g_x = \frac{\partial f}{\partial x}=P9-P5$$

$g_y = \frac{\partial f}{\partial y}=P8-P6$

**Roberts算子**利用局部差分算子寻找边缘，边缘定位精度较高，但容易丢失一部分边缘，不具备抑制噪声的能力。该算子对具有陡峭边缘且含噪声少的图像效果较好，尤其是边缘正负45度较多的图像，但定位准确率较差；

### 1.2 Prewitt算子

Prewitt算子是一种图像边缘检测的微分算子，其原理是利用特定区域内像素灰度值产生的差分实现边缘检测。由于Prewitt算子采用 3x3 模板对区域内的像素值进行计算，而Robert算子的模板为 2x2，故Prewitt算子的边缘检测结果在水平方向和垂直方向均比Robert算子更加明显。Prewitt算子适合用来识别噪声较多、灰度渐变的图像，其计算公式如下所示：
$d_x = \begin{bmatrix} -1 & 0 & 1\\ -1 & 0 & 1\\ -1 & 0 & 1\end{bmatrix}, d_y=\begin{bmatrix}
 -1 & -1 & -1\\
 0 & 0 & 0\\
 1 & 1 & 1
\end{bmatrix}$

**Prewitt算子**对灰度渐变的图像边缘提取效果较好，而没有考虑相邻点的距离远近对当前像素点的影响，与Sobel 算子类似，不同的是在平滑部分的权重大小有些差异；

### 2.3 Sobel算子

Sobel算子是一种用于边缘检测的离散微分算子，它结合了高斯平滑和微分求导。该算子用于计算图像明暗程度近似值，根据图像边缘旁边明暗程度把该区域内超过某个数的特定点记为边缘。Sobel算子在Prewitt算子的基础上增加了**权重**的概念，认为相邻点的距离远近对当前像素点的影响是不同的，距离越近的像素点对应当前像素的影响越大，从而实现图像锐化并突出边缘轮廓。

Sobel算子根据像素点上下、左右邻点灰度加权差，在边缘处达到极值这一现象检测边缘。对噪声具有平滑作用，提供较为精确的边缘方向信息。因为Sobel算子结合了高斯平滑和微分求导（分化），因此结果会具有更多的抗噪性，当对精度要求不是很高时，Sobel算子是一种较为常用的边缘检测方法。

Sobel算子的边缘定位更准确，常用于噪声较多、灰度渐变的图像。其算法模板如下面的公式所示，其中 $d_x$表示水平方向，$d_y$表示垂直方向。

$d_x = \begin{bmatrix} -1 & 0 & 1\\ -2 & 0 & 2\\ -1 & 0 & 1\end{bmatrix}, d_y=\begin{bmatrix}
 -1 & -2 & -1\\
 0 & 0 & 0\\
 1 & 2 & 1
\end{bmatrix}$

sobel算子在opencv有现成的函数，而其他的算子需要先用numpy定义一下数组，在调用opencv的filter2D函数。

**Sobel算子**考虑了综合因素，对噪声较多的图像处理效果更好，Sobel 算子边缘定位效果不错，但检测出的边缘容易出现多像素宽度。

## 2.二阶导数的边缘算子

依据为二阶导数在边缘处为零点，常见的有Laplacian算子，但是对噪声敏感。还有LOG(Laplacian of Gaussian)、DOG(difference of  Gaussian)算子。

### 2.1 Laplacian算子

**拉普拉斯(Laplacian) 算子**是 $n$ 维欧几里德空间中的一个**二阶微分算子**，常用于图像增强领域和边缘提取。它通过灰度差分计算邻域内的像素。

**算法流程**

1. 判断图像中心像素灰度值与它周围其他像素的灰度值，如果中心像素的灰度更高，则提升中心像素的灰度；反之降低中心像素的灰度，从而实现图像锐化操作；
2. 在算法实现过程中，Laplacian算子通过对邻域中心像素的四方向或八方向求梯度，再将梯度相加起来判断中心像素灰度与邻域内其他像素灰度的关系；
3. 最后通过梯度运算的结果对像素灰度进行调整。

Laplacian算子分为四邻域和八邻域，四邻域是对邻域中心像素的四个方向求梯度，八邻域是对八个方向求梯度。

其中，Laplacian算子的四邻域模板为$H=\begin{bmatrix}
 0 & -1 & 0\\
 -1 & 4 & -1\\
 0 & -1 & 0
\end{bmatrix}$，Laplacian算子的八邻域模板为$H=\begin{bmatrix}
 -1 & -1 & -1\\
 -1 & 8 & -1\\
 -1 & -1 & -1
\end{bmatrix}$。

通过Laplacian算子的模板可以发现：

1）当邻域内像素灰度相同时，模板的卷积运算结果为0；

2）当中心像素灰度高于邻域内其他像素的平均灰度时，模板的卷积运算结果为正数；

3）当中心像素的灰度低于邻域内其他像素的平均灰度时，模板的卷积为负数。对卷积运算的结果用适当的衰弱因子处理并加在原中心像素上，就可以实现图像的锐化处理。
Python和OpenCV将Laplacian算子封装在 **Laplacian()** 函数中

Laplacian 算子不依赖于边缘方向的二阶微分算子，对图像中的阶跃型边缘点定位准确，该算子对噪声非常敏感，它使噪声成分得到加强，这两个特性使得该算子容易丢失一部分边缘的方向信息，造成一些不连续的检测边缘，同时抗噪声能力比较差，由于其算法可能会出现双像素边界，**常用来判断边缘像素位于图像的明区或暗区**，很少用于边缘检测；

### 2.2 LOG算子

上面提到先对图像做高斯平滑，再和Laplacian算子进行卷积。这种操作还有一种是LOG算子。下面推导一下

二维高斯函数为$G_{\sigma}(x, y)=\frac{1}{\sqrt{2\pi\sigma ^2}}\exp(-\frac{x^2+y^2}{2\sigma ^2})$，图像矩阵为$I(x, y)$，和图像进行卷积有$\Delta(G_{\sigma}(x, y) * I(x, y))=\Delta(G_{\sigma}(x, y))*I(x, y)$，($*$代表卷积操作)等式左边是指上面Laplacian算子的操作，先进行高斯平滑再和Laplacian算子进行卷积操作；等式右边就代表LOG的操作，先对高斯平滑求二阶导（Laplacian操作），再和图像进行卷积操作。等式变换的依据是

$\frac{d}{dt}[h(t)*f(t)]=\frac{d}{dt}\int_{\tau}f(\tau)h(t-\tau)d\tau=\int_{\tau}f(\tau)\frac{d}{dt}h(t-\tau)d\tau = f(t)*\frac{d}{dt}h(t)$

对高斯公式应用Laplacian算子

$\Delta G_{\sigma}(x, y) = \frac{\partial ^2 G}{\partial x^2}+\frac{\partial ^2 G}{\partial y^2}$，$\frac{\partial G}{\partial x}=\frac{1}{\sqrt{2\pi \sigma^2}}\cdot (-\frac{x}{\sigma ^2})\exp(-\frac{x^2+y^2}{2\sigma^2})$，所以$\frac{\partial^2 G}{\partial x^2}=-\frac{1}{\sigma^3 \sqrt{2\pi}}\exp(-\frac{x^2+y^2}{2\sigma^2})+\frac{x^2}{\sigma^5 \sqrt{2\pi}}\exp(-\frac{x^2+y^2}{2\sigma^2})$ 。

所以对$y$求偏导类似，最后得到

$\Delta G_{\sigma}(x, y) = \frac{1}{\sqrt{2\pi}}\exp(-\frac{x^2+y^2}{2\sigma^2})\cdot \frac{x^2+y^2-2\sigma ^2}{\sigma^5}$




## 3.其他边缘算子

前面两类均是通过微分算子来检测图像边缘，还有一种就是Canny算子，其是在满足一定约束条件下推导出来的边缘检测最优化算子。

SUSAN算子、相位一致性

### 3.1 SUSAN算子

参考文章：https://blog.csdn.net/songzitea/article/details/8762846

